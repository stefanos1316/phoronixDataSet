/***************************************************************************
 *   Copyright (C) 2006, 2007, 2008 by Jan Fostier                         *
 *   jan.fostier@intec.ugent.be                                            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "mathlib.h"
#include <cstdlib>
#include <iostream>

#ifdef HAVE_CONFIG_H
        #include <config.h>
#endif

using namespace std;

// ========================================================================
// AMOS LIBRARY FUNCTION PROTOTYPES
// ========================================================================

#define zbesj_f77 F77_FUNC (zbesj, ZBESJ)
#define zbesy_f77 F77_FUNC (zbesy, ZBESY)
#define zbesh_f77 F77_FUNC (zbesh, ZBESH)

extern "C" void zbesh_f77(double *zr, double *zi, double *fnu, int *kode,
                          int *m, int *n, double *cyr, double *cyi, int *nz,
                          int *ierr);
extern "C" void zbesj_f77(double *zr, double *zi, double *fnu, int *kode,
                          int *NN, double *cyr, double *cyi, int *nz,
                          int *ierr);
extern "C" void zbesy_f77(double *zr, double *zi, double *fnu, int *kode,
                          int *NN, double *cyr, double *cyi, int *nz,
                          double *work1, double *work2, int *ierr);
extern "C" void zbesk_f77(double *zr, double *zi, double *fnu, int *kode,
                          int *n, double *cyr, double *cyi, int *nz, int *ierr);

// ========================================================================
// GAUSSIAN QUADRATURE
// ========================================================================

// gaussian quadrature weights
const double gaussWeight2[2]= { 1, 1 };
const double gaussWeight4[4]= {
0.34785484513745402, 0.65214515486254598, 0.65214515486254598,
0.34785484513745402 };
const double gaussWeight6[6]= {
0.17132449237917   , 0.36076157304813899, 0.46791393457269098,
0.46791393457269098, 0.36076157304813899, 0.17132449237917 };
const double gaussWeight7[7]= {
0.129484966168870, 0.279705391489277, 0.381830050505119,
0.417959183673469, 0.381830050505119, 0.279705391489277,
0.129484966168870 };
const double gaussWeight8[8]= {
0.10122853629037626, 0.22238103445337447, 0.31370664587788729,
0.36268378337836198, 0.36268378337836198, 0.31370664587788729,
0.22238103445337447, 0.10122853629037626 };
const double gaussWeight9[9]= {
0.081274388361574, 0.180648160694857, 0.260610696402935,
0.312347077040003, 0.330239355001260, 0.312347077040003,
0.260610696402935, 0.180648160694857, 0.081274388361574 };
const double gaussWeight10[10]= {
0.066671344308687999, 0.149451349150581  , 0.21908636251598201,
0.26926671930999602 , 0.29552422471475298, 0.29552422471475298,
0.26926671930999602 , 0.21908636251598201, 0.149451349150581,
0.066671344308687999 };
const double gaussWeight12[12]= {
0.047175336386512001, 0.106939325995318, 0.160078328543346,
0.20316742672306601 , 0.233492536538355, 0.249147045813403,
0.249147045813403   , 0.233492536538355, 0.20316742672306601,
0.160078328543346   , 0.106939325995318, 0.047175336386512001 };
const double gaussWeight16[16]= {
0.02715245941175409, 0.06225352393864789, 0.09515851168249278,
0.12462897125553387, 0.14959598881657673, 0.16915651939500254,
0.18260341504492359, 0.18945061045506850, 0.18945061045506850,
0.18260341504492359, 0.16915651939500254, 0.14959598881657673,
0.12462897125553387, 0.09515851168249278, 0.06225352393864789,
0.02715245941175409 };
const double gaussWeight20[20]= {
0.017614007139152118312, 0.040601429800386941331, 0.062672048334109063570,
0.083276741576704748725, 0.101930119817240435037, 0.118194531961518417312,
0.131688638449176626898, 0.142096109318382051329, 0.149172986472603746788,
0.152753387130725850698, 0.152753387130725850698, 0.149172986472603746788,
0.142096109318382051329, 0.131688638449176626898, 0.118194531961518417312,
0.101930119817240435037, 0.083276741576704748725, 0.062672048334109063570,
0.040601429800386941331, 0.017614007139152118312 };
const double gaussWeight24[24]= {
0.0123412297999872  , 0.028531388628933663, 0.044277438817419808,
0.059298584915436783, 0.0733464814110803  , 0.086190161531953274,
0.097618652104113884, 0.10744427011596563 , 0.1155056680537256,
0.12167047292780339 , 0.1258374563468283  , 0.12793819534675216,
0.12793819534675216 , 0.1258374563468283  , 0.12167047292780339,
0.1155056680537256  , 0.10744427011596563 , 0.097618652104113884,
0.086190161531953274, 0.0733464814110803  , 0.059298584915436783,
0.044277438817419808, 0.028531388628933663, 0.0123412297999872 };
const double gaussWeight32[32]= {
0.0070186100094700964, 0.01627439473090567  , 0.025392065309262059,
0.034273862913021431 , 0.042835898022226683 , 0.050998059262376175,
0.058684093478535544 , 0.065822222776361849 , 0.072345794108848505,
0.078193895787070311 , 0.083311924226946749 , 0.087652093004403811,
0.091173878695763891 , 0.093844399080804566 , 0.095638720079274861,
0.096540088514727798 , 0.096540088514727798 , 0.095638720079274861,
0.093844399080804566 , 0.091173878695763891 , 0.087652093004403811,
0.083311924226946749 , 0.078193895787070311 , 0.072345794108848505,
0.065822222776361849 , 0.058684093478535544 , 0.050998059262376175,
0.042835898022226683 , 0.034273862913021431 , 0.025392065309262059,
0.01627439473090567  , 0.0070186100094700964 };
const double gaussWeight40[40]= {
0.00452127709853319, 0.01049828453115281, 0.01642105838190789,
0.02224584919416696, 0.02793700698002340, 0.03346019528254785,
0.03878216797447202, 0.04387090818567327, 0.04869580763507223,
0.05322784698393682, 0.05743976909939155, 0.06130624249292894,
0.06480401345660104, 0.06791204581523390, 0.07061164739128678,
0.07288658239580406, 0.07472316905796826, 0.07611036190062624,
0.07703981816424797, 0.07750594797842481, 0.07750594797842481,
0.07703981816424797, 0.07611036190062624, 0.07472316905796826,
0.07288658239580406, 0.07061164739128678, 0.06791204581523390,
0.06480401345660104, 0.06130624249292894, 0.05743976909939155,
0.05322784698393682, 0.04869580763507223, 0.04387090818567327,
0.03878216797447202, 0.03346019528254785, 0.02793700698002340,
0.02224584919416696, 0.01642105838190789, 0.01049828453115281,
0.00452127709853319 };
const double gaussWeight48[48]= {
0.0031533460523058385, 0.0073275539012762625, 0.01147723457923454,
0.015579315722943849 , 0.019616160457355529 , 0.02357076083932438,
0.027426509708356497 , 0.03116722783279809  , 0.034777222564770442,
0.038241351065830709 , 0.041545082943464748 , 0.04467456085669428,
0.047616658492490478 , 0.050359035553854473 , 0.052890189485193667,
0.055199503699984165 , 0.057277292100403214 , 0.059114839698395635,
0.060704439165893881 , 0.062039423159892665 , 0.06311419228625402,
0.063924238584648185 , 0.064466164435950088 , 0.064737696812683918,
0.064737696812683918 , 0.064466164435950088 , 0.063924238584648185,
0.06311419228625402  , 0.062039423159892665 , 0.060704439165893881,
0.059114839698395635 , 0.057277292100403214 , 0.055199503699984165,
0.052890189485193667 , 0.050359035553854473 , 0.047616658492490478,
0.04467456085669428  , 0.041545082943464748 , 0.038241351065830709,
0.034777222564770442 , 0.03116722783279809  , 0.027426509708356497,
0.02357076083932438  , 0.019616160457355529 , 0.015579315722943849,
0.01147723457923454  , 0.0073275539012762625, 0.0031533460523058385 };
const double gaussWeight64[64]= {
0.00178328072169643, 0.00414703326056247, 0.00650445796897836,
0.00884675982636395, 0.01116813946013113, 0.01346304789671864,
0.01572603047602472, 0.01795171577569734, 0.02013482315353021,
0.02227017380838325, 0.02435270256871087, 0.02637746971505466,
0.02833967261425948, 0.03023465707240248, 0.03205792835485155,
0.03380516183714161, 0.03547221325688238, 0.03705512854024005,
0.03855015317861563, 0.03995374113272034, 0.04126256324262353,
0.04247351512365359, 0.04358372452932345, 0.04459055816375656,
0.04549162792741814, 0.04628479658131442, 0.04696818281621002,
0.04754016571483031, 0.04799938859645831, 0.04834476223480296,
0.04857546744150343, 0.04869095700913972, 0.04869095700913972,
0.04857546744150343, 0.04834476223480296, 0.04799938859645831,
0.04754016571483031, 0.04696818281621002, 0.04628479658131442,
0.04549162792741814, 0.04459055816375656, 0.04358372452932345,
0.04247351512365359, 0.04126256324262353, 0.03995374113272034,
0.03855015317861563, 0.03705512854024005, 0.03547221325688238,
0.03380516183714161, 0.03205792835485155, 0.03023465707240248,
0.02833967261425948, 0.02637746971505466, 0.02435270256871087,
0.02227017380838325, 0.02013482315353021, 0.01795171577569734,
0.01572603047602472, 0.01346304789671864, 0.01116813946013113,
0.00884675982636395, 0.00650445796897836, 0.00414703326056247,
0.00178328072169643 };
const double gaussWeight80[80]= {
0.0011449500031869414, 0.0026635335895126818, 0.0041803131246948956,
0.0056909224514031988, 0.0071929047681173128, 0.0086839452692608586,
0.010161766041103065 , 0.011624114120797826 , 0.01306876159240134,
0.014493508040509076 , 0.015896183583725687 , 0.017274652056269307,
0.018626814208299033 , 0.019950610878142001 , 0.021244026115782005,
0.022505090246332463 , 0.023731882865930101 , 0.024922535764115492,
0.026075235767565118 , 0.02718822750048638  , 0.028259816057276864,
0.029288369583287847 , 0.03027232175955798  , 0.031210174188114701,
0.032100498673487771 , 0.032941939397645399 , 0.033733214984611522,
0.034473120451753929 , 0.03516052904474759  , 0.035794393953416055,
0.03637374990583598  , 0.036897714638276007 , 0.037365490238730488,
0.037776364362001401 , 0.038129711314477635 , 0.038424993006959424,
0.038661759774076467 , 0.038839651059051968 , 0.038958395962769531,
0.039017813656306653 , 0.039017813656306653 , 0.038958395962769531,
0.038839651059051968 , 0.038661759774076467 , 0.038424993006959424,
0.038129711314477635 , 0.037776364362001401 , 0.037365490238730488,
0.036897714638276007 , 0.03637374990583598  , 0.035794393953416055,
0.03516052904474759  , 0.034473120451753929 , 0.033733214984611522,
0.032941939397645399 , 0.032100498673487771 , 0.031210174188114701,
0.03027232175955798  , 0.029288369583287847 , 0.028259816057276864,
0.02718822750048638  , 0.026075235767565118 , 0.024922535764115492,
0.023731882865930101 , 0.022505090246332463 , 0.021244026115782005,
0.019950610878142001 , 0.018626814208299033 , 0.017274652056269307,
0.015896183583725687 , 0.014493508040509076 , 0.01306876159240134,
0.011624114120797826 , 0.010161766041103065 , 0.0086839452692608586,
0.0071929047681173128, 0.0056909224514031988, 0.0041803131246948956,
0.0026635335895126818, 0.0011449500031869414 };
const double gaussWeight96[96]= {
0.00079679206555201244, 0.0018539607889469217, 0.0029107318179349465,
0.0039645543384446867 , 0.0050142027429275178, 0.0060585455042359614,
0.0070964707911538652 , 0.0081268769256987589, 0.009148671230783386,
0.010160770535008416  , 0.011162102099838499 , 0.01215160467108832,
0.013128229566961573  , 0.014090941772314861 , 0.015038721026994937,
0.015970562902562293  , 0.016885479864245174 , 0.017782502316045262,
0.018660679627411466  , 0.019519081140145021 , 0.020356797154333323,
0.021172939892191298  , 0.02196664443874435  , 0.022737069658329372,
0.02348339908592622   , 0.024204841792364692 , 0.02490063322248361,
0.025570036005349361  , 0.026212340735672413 , 0.026826866725591762,
0.027412962726029243  , 0.027970007616848334 , 0.028497411065085385,
0.028994614150555237  , 0.029461089958167905 , 0.029896344136328384,
0.030299915420827595  , 0.030671376123669148 , 0.031010332586313836,
0.031316425596861354  , 0.031589330770727168 , 0.031828758894411009,
0.032034456231992664  , 0.032206204794030253 , 0.032343822568575931,
0.032447163714064267  , 0.032516118713868836 , 0.03255061449236317,
0.03255061449236317   , 0.032516118713868836 , 0.032447163714064267,
0.032343822568575931  , 0.032206204794030253 , 0.032034456231992664,
0.031828758894411009  , 0.031589330770727168 , 0.031316425596861354,
0.031010332586313836  , 0.030671376123669148 , 0.030299915420827595,
0.029896344136328384  , 0.029461089958167905 , 0.028994614150555237,
0.028497411065085385  , 0.027970007616848334 , 0.027412962726029243,
0.026826866725591762  , 0.026212340735672413 , 0.025570036005349361,
0.02490063322248361   , 0.024204841792364692 , 0.02348339908592622,
0.022737069658329372  , 0.02196664443874435  , 0.021172939892191298,
0.020356797154333323  , 0.019519081140145021 , 0.018660679627411466,
0.017782502316045262  , 0.016885479864245174 , 0.015970562902562293,
0.015038721026994937  , 0.014090941772314861 , 0.013128229566961573,
0.01215160467108832   , 0.011162102099838499 , 0.010160770535008416,
0.009148671230783386  , 0.0081268769256987589, 0.0070964707911538652,
0.0060585455042359614 , 0.0050142027429275178, 0.0039645543384446867,
0.0029107318179349465 , 0.0018539607889469217, 0.00079679206555201244 };

// gaussian quadrature points for integration between -1 and 1
const double gaussQP2[2]= {
-0.57735026918962573106, 0.57735026918962573106 };
const double gaussQP4[4]= {
-0.86113631159405302, -0.33998104358485598, 0.33998104358485598,
0.86113631159405302 };
const double gaussQP6[6]= {
-0.93246951420315205, -0.66120938646626504, -0.23861918608319699,
0.23861918608319699,  0.66120938646626504,  0.93246951420315205 };
const double gaussQP7[7]= {
-0.949107912342759, -0.741531185599394, -0.405845151377397,
0.000000000000000,  0.405845151377397,  0.741531185599394,
0.949107912342759 };
const double gaussQP8[8]= {
-0.96028985649753623, -0.79666647741362674, -0.52553240991632899,
-0.18343464249564980,  0.18343464249564980,  0.52553240991632899,
0.79666647741362674,  0.96028985649753623 };
const double gaussQP9[9]= {
-0.968160239507626, -0.836031107326636, -0.613371432700590,
-0.324253423403809,  0.000000000000000,  0.324253423403809,
0.613371432700590,  0.836031107326636,  0.968160239507626 };
const double gaussQP10[10]= {
-0.97390652851717197, -0.86506336668898498, -0.67940956829902399,
-0.43339539412924699, -0.14887433898163099,  0.14887433898163099,
0.43339539412924699,  0.67940956829902399,  0.86506336668898498,
0.97390652851717197 };
const double gaussQP12[12]= {
-0.98156063424671902, -0.90411725637047502, -0.76990267419430503,
-0.58731795428661704, -0.36783149899818002, -0.125233408511469,
0.125233408511469  ,  0.36783149899818002,  0.58731795428661704,
0.76990267419430503,  0.90411725637047502,  0.98156063424671902 };
const double gaussQP16[16]= {
-0.98940093499164993, -0.94457502307323258, -0.86563120238783174,
-0.75540440835500303, -0.61787624440264375, -0.45801677765722739,
-0.28160355077925891, -0.09501250983763744,  0.09501250983763744,
0.28160355077925891,  0.45801677765722739,  0.61787624440264375,
0.75540440835500303,  0.86563120238783174,  0.94457502307323258,
0.98940093499164993 };
const double gaussQP20[20]= {
-0.99312859918509488 , -0.96397192727791381 , -0.91223442825132595,
-0.83911697182221878 , -0.7463319064601508  , -0.63605368072651502,
-0.51086700195082713 , -0.37370608871541955 , -0.22778585114164507,
-0.076526521133497338,  0.076526521133497338,  0.22778585114164507,
0.37370608871541955 ,  0.51086700195082713 ,  0.63605368072651502,
0.7463319064601508  ,  0.83911697182221878 ,  0.91223442825132595,
0.96397192727791381 ,  0.99312859918509488 };
const double gaussQP24[24]= {
-0.99518721999702131, -0.97472855597130947, -0.9382745520027328,
-0.88641552700440107, -0.82000198597390295, -0.74012419157855436,
-0.64809365193697555, -0.54542147138883956, -0.43379350762604513,
-0.3150426796961634 , -0.19111886747361631, -0.06405689286260563,
0.06405689286260563,  0.19111886747361631,  0.3150426796961634,
0.43379350762604513,  0.54542147138883956,  0.64809365193697555,
0.74012419157855436,  0.82000198597390295,  0.88641552700440107,
0.9382745520027328 ,  0.97472855597130947,  0.99518721999702131 };
const double gaussQP32[32]= {
-0.99726386184948157 , -0.98561151154526838 , -0.96476225558750639,
-0.93490607593773967 , -0.89632115576605209 , -0.84936761373256997,
-0.79448379596794239 , -0.73218211874028971 , -0.66304426693021523,
-0.5877157572407623  , -0.50689990893222936 , -0.42135127613063533,
-0.33186860228212767 , -0.23928736225213706 , -0.14447196158279649,
-0.048307665687738317,  0.048307665687738317,  0.14447196158279649,
0.23928736225213706 ,  0.33186860228212767 ,  0.42135127613063533,
0.50689990893222936 ,  0.5877157572407623  ,  0.66304426693021523,
0.73218211874028971 ,  0.79448379596794239 ,  0.84936761373256997,
0.89632115576605209 ,  0.93490607593773967 ,  0.96476225558750639,
0.98561151154526838 ,  0.99726386184948157 };
const double gaussQP40[40]= {
-0.99823770971055920, -0.99072623869945701, -0.97725994998377426,
-0.95791681921379166, -0.93281280827867653, -0.90209880696887430,
-0.86595950321225950, -0.82461223083331166, -0.77830565142651939,
-0.72731825518992710, -0.67195668461417955, -0.61255388966798024,
-0.54946712509512820, -0.48307580168617871, -0.41377920437160500,
-0.34199409082575847, -0.26815218500725368, -0.19269758070137110,
-0.11608407067525521, -0.03877241750605082,  0.03877241750605082,
0.11608407067525521,  0.19269758070137110,  0.26815218500725368,
0.34199409082575847,  0.41377920437160500,  0.48307580168617871,
0.54946712509512820,  0.61255388966798024,  0.67195668461417955,
0.72731825518992710,  0.77830565142651939,  0.82461223083331166,
0.86595950321225950,  0.90209880696887430,  0.93281280827867653,
0.95791681921379166,  0.97725994998377426,  0.99072623869945701,
0.99823770971055920 };
const double gaussQP48[48]= {
-0.99877100725242607, -0.99353017226635076 , -0.98412458372282685,
-0.97059159254624727, -0.95298770316043091 , -0.93138669070655433,
-0.90587913671556963, -0.87657202027424785 , -0.84358826162439349,
-0.80706620402944262, -0.76715903251574036 , -0.72403413092381463,
-0.67787237963266389, -0.6288673967765136  , -0.57722472608397268,
-0.523160974722233  , -0.46690290475095841 , -0.40868648199071672,
-0.34875588629216075, -0.28736248735545555 , -0.22476379039468905,
-0.16122235606889171, -0.097004699209462697, -0.03238017096286936,
0.03238017096286936,  0.097004699209462697,  0.16122235606889171,
0.22476379039468905,  0.28736248735545555 ,  0.34875588629216075,
0.40868648199071672,  0.46690290475095841 ,  0.523160974722233,
0.57722472608397268,  0.6288673967765136  ,  0.67787237963266389,
0.72403413092381463,  0.76715903251574036 ,  0.80706620402944262,
0.84358826162439349,  0.87657202027424785 ,  0.90587913671556963,
0.93138669070655433,  0.95298770316043091 ,  0.97059159254624727,
0.98412458372282685,  0.99353017226635076 ,  0.99877100725242607 };
const double gaussQP64[64]= {
-0.99930504173577214, -0.99634011677195528, -0.99101337147674432,
-0.98333625388462596, -0.97332682778991096, -0.96100879965205372,
-0.94641137485840282, -0.92956917213193958, -0.91052213707850281,
-0.88931544599511411, -0.86599939815409282, -0.84062929625258036,
-0.81326531512279756, -0.78397235894334141, -0.75281990726053190,
-0.71988185017161083, -0.68523631305423324, -0.64896547125465734,
-0.61115535517239325, -0.57189564620263403, -0.53127946401989455,
-0.48940314570705296, -0.44636601725346409, -0.40227015796399160,
-0.35722015833766812, -0.31132287199021096, -0.26468716220876742,
-0.21742364374000708, -0.16964442042399282, -0.12146281929612055,
-0.07299312178779904, -0.02435029266342443,  0.02435029266342443,
0.07299312178779904,  0.12146281929612055,  0.16964442042399282,
0.21742364374000708,  0.26468716220876742,  0.31132287199021096,
0.35722015833766812,  0.40227015796399160,  0.44636601725346409,
0.48940314570705296,  0.53127946401989455,  0.57189564620263403,
0.61115535517239325,  0.64896547125465734,  0.68523631305423324,
0.71988185017161083,  0.75281990726053190,  0.78397235894334141,
0.81326531512279756,  0.84062929625258036,  0.86599939815409282,
0.88931544599511411,  0.91052213707850281,  0.92956917213193958,
0.94641137485840282,  0.96100879965205372,  0.97332682778991096,
0.98333625388462596,  0.99101337147674432,  0.99634011677195528,
0.99930504173577214 };
const double gaussQP80[80]= {
-0.99955382265163062 , -0.99764986439823766 , -0.99422754096568833,
-0.9892913024997555  , -0.98284857273862902 , -0.97490914058572775,
-0.96548508904379926 , -0.95459076634363493 , -0.94224276130987272,
-0.92845987717244582 , -0.91326310257175769 , -0.89667557943877063,
-0.87872256767821388 , -0.85943140666311113 , -0.83883147358025523,
-0.81695413868146349 , -0.79383271750460549 , -0.76950242013504133,
-0.74400029758359731 , -0.71736518536209992 , -0.68963764434202757,
-0.66085989898611985 , -0.63107577304687201 , -0.60033062282975169,
-0.56867126812270974 , -0.53614592089713198 , -0.50280411188874896,
-0.46869661517054445 , -0.43387537083175609 , -0.39839340588196925,
-0.36230475349948732 , -0.32566437074770122 , -0.28852805488451183,
-0.25095235839227215 , -0.21299450285766613 , -0.1747122918326468,
-0.13616402280914389 , -0.097408398441584595, -0.058504437152420666,
-0.019511383256793996,  0.019511383256793996,  0.058504437152420666,
0.097408398441584595,  0.13616402280914389 ,  0.1747122918326468,
0.21299450285766613 ,  0.25095235839227215 ,  0.28852805488451183,
0.32566437074770122 ,  0.36230475349948732 ,  0.39839340588196925,
0.43387537083175609 ,  0.46869661517054445 ,  0.50280411188874896,
0.53614592089713198 ,  0.56867126812270974 ,  0.60033062282975169,
0.63107577304687201 ,  0.66085989898611985 ,  0.68963764434202757,
0.71736518536209992 ,  0.74400029758359731 ,  0.76950242013504133,
0.79383271750460549 ,  0.81695413868146349 ,  0.83883147358025523,
0.85943140666311113 ,  0.87872256767821388 ,  0.89667557943877063,
0.91326310257175769 ,  0.92845987717244582 ,  0.94224276130987272,
0.95459076634363493 ,  0.96548508904379926 ,  0.97490914058572775,
0.98284857273862902 ,  0.9892913024997555  ,  0.99422754096568833,
0.99764986439823766 ,  0.99955382265163062 };
const double gaussQP96[96]= {
-0.99968950388323075 , -0.99836437586318172, -0.99598184298720926,
-0.99254390032376261 , -0.98805412632962375, -0.98251726356301472,
-0.97593917458513646 , -0.96832682846326423, -0.95968829144874257,
-0.95003271778443765 , -0.93937033975275519, -0.92771245672230873,
-0.91507142312089806 , -0.9014606353158523 , -0.88689451740242042,
-0.87138850590929651 , -0.85495903343460145, -0.83762351122818712,
-0.81940031073793163 , -0.80030874413914077, -0.78036904386743322,
-0.75960234117664749 , -0.73803064374440008, -0.71567681234896763,
-0.69256453664217155 , -0.66871831004391613, -0.64416340378496706,
-0.61892584012546858 , -0.59303236477757204, -0.56651041856139717,
-0.53938810832435746 , -0.5116941771546677 , -0.48345797392059636,
-0.45470942216774302 , -0.42547898840730053, -0.39579764982890858,
-0.36569686147231362 , -0.33520852289262543, -0.30436494435449635,
-0.27319881259104917 , -0.24174315616384001, -0.21003131046056719,
-0.17809688236761861 , -0.14597371465489695, -0.11369585011066592,
-0.081297495464425565, -0.04881298513604973, -0.016276744849602971,
0.016276744849602971,  0.04881298513604973,  0.081297495464425565,
0.11369585011066592 ,  0.14597371465489695,  0.17809688236761861,
0.21003131046056719 ,  0.24174315616384001,  0.27319881259104917,
0.30436494435449635 ,  0.33520852289262543,  0.36569686147231362,
0.39579764982890858 ,  0.42547898840730053,  0.45470942216774302,
0.48345797392059636 ,  0.5116941771546677 ,  0.53938810832435746,
0.56651041856139717 ,  0.59303236477757204,  0.61892584012546858,
0.64416340378496706 ,  0.66871831004391613,  0.69256453664217155,
0.71567681234896763 ,  0.73803064374440008,  0.75960234117664749,
0.78036904386743322 ,  0.80030874413914077,  0.81940031073793163,
0.83762351122818712 ,  0.85495903343460145,  0.87138850590929651,
0.88689451740242042 ,  0.9014606353158523 ,  0.91507142312089806,
0.92771245672230873 ,  0.93937033975275519,  0.95003271778443765,
0.95968829144874257 ,  0.96832682846326423,  0.97593917458513646,
0.98251726356301472 ,  0.98805412632962375,  0.99254390032376261,
0.99598184298720926 ,  0.99836437586318172,  0.99968950388323075 };

// pointer to the respective weights and quadrature points
const double* stdGaussWeight[97] = { NULL, NULL, gaussWeight2, NULL,
        gaussWeight4, NULL, gaussWeight6, gaussWeight7, gaussWeight8,
        gaussWeight9, gaussWeight10, NULL, gaussWeight12, NULL, NULL, NULL,
        gaussWeight16, NULL, NULL, NULL, gaussWeight20, NULL, NULL, NULL,
        gaussWeight24, NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussWeight32,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussWeight40, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, gaussWeight48, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
        gaussWeight64, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, gaussWeight80, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
        gaussWeight96 };

const double* stdGaussQP[97] = { NULL, NULL, gaussQP2, NULL, gaussQP4, NULL,
        gaussQP6, gaussQP7, gaussQP8, gaussQP9, gaussQP10, NULL, gaussQP12,
        NULL, NULL, NULL, gaussQP16, NULL, NULL, NULL, gaussQP20, NULL, NULL,
        NULL, gaussQP24, NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussQP32,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussQP40, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, gaussQP48, NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussQP64, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, gaussQP80, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL, gaussQP96};

dcomplex gaussQuadr(dcomplex* f, int qOrder, double a, double b)
{
        dcomplex result = 0;
        for(int i = 0; i < qOrder; i++)
                result = result + f[i]*stdGaussWeight[qOrder][i];

        return result*((b-a)/2.0f); // correction due to dx' = A*dx
}

void getGaussQP(double* gaussQP, int qOrder, double a, double b)
{
        double A = (b-a)/2.0f; // coefficients for transformation x'= Ax+B
        double B = (a+b)/2.0f; // where x' is the new integration parameter

        for(int i = 0; i < qOrder; i++)
                gaussQP[i] = A*stdGaussQP[qOrder][i]+B;
}

bool gaussQuadrOrderIsSupported(int qOrder)
{
        if ((qOrder < 0) || (qOrder > 96)) return false;
        if (stdGaussQP[qOrder] == NULL) return false;

        return true;
}

// ========================================================================
// ZHANG AND JIN BESSEL AND HANKEL FUNCTIONS (fastest)
// ========================================================================

void ZhangJinHank0Real(double x, dcomplex *result)
{
        double BJ0, BY0;

        if (x <= 4) {
                double t = x * 0.25;
                double t2 = t*t;
                double logv = log(x * 0.5);

                BJ0 = ((((((-0.0005014415*t2+0.0076771853)*t2-0.0709253492)*t2+
                                0.4443584263)*t2-1.7777560599)*t2+3.9999973021)*
                                t2-3.9999998721)*t2+1.0;
                BY0 = ((((((((-0.0000567433*t2+0.0008599770)*t2-
                                0.0094855882)*t2+0.0772975809)*t2-0.4261737419)*
                                t2+1.4216421221)*t2-2.3498519931)*t2+
                                1.0766115157)*t2+0.3674669052);
                BY0 += 2.0*oopi*logv*BJ0;
        } else {
                double oox = 1/x;
                double t = 4.0 * oox;
                double t2 = t*t;
                double a0 = sqrt(2.0*oopi*oox);
                double P0, Q0;

                P0 = ((((-0.000009285*t2+0.000043506)*t2-0.000122226)*t2+
                                0.000434725)*t2-0.004394275)*t2+0.999999997;
                Q0 = t*(((((0.000008099*t2-0.000035614)*t2+0.000085844)*t2-
                                0.000218024)*t2+0.001144106)*t2-0.031249995);

                double TA0 = x - 0.25 * pi;
                double cosv = cos(TA0);
                double sinv = sin(TA0);

                BJ0 = a0*(P0*cosv-Q0*sinv);
                BY0 = a0*(P0*sinv+Q0*cosv);
        }

        result[0] = BJ0 - I*BY0;
}

void ZhangJinHank0Complex(dcomplex z, dcomplex *result)
{
        dcomplex BJ0, BY0;
        double norm = abs(z);
        double RP2 = 2.0 * oopi;
        dcomplex z1 = z;
        dcomplex ooz = 1./z;
        int k;

        if (norm < 12.0) { // for small arguments: use the series expansion

                dcomplex z2 = -0.25*z*z;
                double eps = 1e-10;
                double gamma = 0.5772156649015329;
                dcomplex logv = log(z1*0.5)+gamma;

                BJ0 = 1.0f;
                double W0 = 0;
                dcomplex CR1 = 1, CR0 = 1, CP1, CP2, CS1 = 1, CS2 = 0;
                double ook = 1.0, ookpe;

                for (k = 2; k < 41; k++) {
                        ookpe = 1.0/k;  // in fact k+1 -> incorporated in loop
                        dcomplex tmp = z2*ook;
                        CR0 *= tmp*ook;
                        CR1 *= tmp*ookpe;
                        BJ0 += CR0;
                        W0 += ook;
                        CP1 = CR1*(2.*W0+ookpe);
                        CP2 = CR0*W0;
                        CS1 += CP1;
                        CS2 += CP2;
                        if ((real(CP1) > -eps) && (imag(CP1) > -eps))
                                if ((real(CP1) <  eps) && (imag(CP1) <  eps))
                                        break;
                        ook = ookpe;
                }
                BY0 = RP2*logv*BJ0-RP2*CS2;
        } else { // for larger arguments: use the asymptotic representation

                double a[12] = {-.703125e-01,.112152099609375e+00,
                        -.5725014209747314e+00,.6074042001273483e+01,
                        -.1100171402692467e+03,.3038090510922384e+04,
                        -.1188384262567832e+06,.6252951493434797e+07,
                        -.4259392165047669e+09,.3646840080706556e+11,
                        -.3833534661393944e+13,.4854014686852901e+15
                };
                double b[12] = {.732421875e-01,-.2271080017089844e+00,
                        .1727727502584457e+01,-.2438052969955606e+02,
                        .5513358961220206e+03,-.1825775547429318e+05,
                        .8328593040162893e+06,-.5006958953198893e+08,
                        .3836255180230433e+10,-.3649010818849833e+12,
                        .4218971570284096e+14,-.5827244631566907e+16
                };

                int k0 = 12;
                if (norm > 35.) k0 = 10;
                if (norm > 50.) k0 = 8;
                dcomplex CT1 = z1-0.25*pi;
                dcomplex CP0 = 1, CR = ooz;
                dcomplex CQ0 = -0.125*ooz;

                for (k = 0; k < k0; k++) {
                        CR *= ooz;
                        CP0 += a[k]*CR;
                        CR *= ooz;
                        CQ0 += b[k]*CR;
                }

                dcomplex CU = sqrt(RP2*ooz);
                dcomplex CUcos = CU*cos(CT1);
                dcomplex CUsin = CU*sin(CT1);

                BJ0 =  CP0*CUcos-CQ0*CUsin;
                BY0 =  CP0*CUsin+CQ0*CUcos;
        }

        result[0] = BJ0 - I*BY0;
}

void ZhangJinHank01Real(double x, dcomplex *result)
{
        double BJ0, BJ1, BY0, BY1;
        double oox = 1/x;

        if (x <= 4) {
                double t = x * 0.25;
                double t2 = t*t;
                double logv = log(x * 0.5);

                BJ0 = ((((((-0.0005014415*t2+0.0076771853)*t2-0.0709253492)*t2+
                                0.4443584263)*t2-1.7777560599)*t2+3.9999973021)*
                                t2-3.9999998721)*t2+1.0;
                BJ1 = t*(((((((-0.0001289769*t2+0.0022069155)*t2-0.0236616773)*
                                t2+0.1777582922)*t2-0.8888839649)*t2+
                                2.6666660544)*t2-3.9999999710)*t2+1.9999999998);
                BY0 = ((((((((-0.0000567433*t2+0.0008599770)*t2-0.0094855882)*
                                t2+0.0772975809)*t2-0.4261737419)*t2+
                                1.4216421221)*t2-2.3498519931)*t2+1.0766115157)*
                                t2+0.3674669052);
                BY0 += 2.0*oopi*logv*BJ0;
                BY1= ((((((((0.0006535773*t2-0.0108175626)*t2+0.1076576060)*t2-
                                0.7268945577)*t2+3.1261399273)*t2-7.3980241381)*
                                t2+6.8529236342)*t2+0.3932562018)*t2-
                                0.6366197726)*oox;
                BY1 = 2.0*oopi*logv*BJ1+BY1;
        } else {
                double t = 4.0 * oox;
                double t2 = t*t;
                double a0 = sqrt(2.0*oopi*oox);
                double P0, P1, Q0, Q1;

                P0 = ((((-0.000009285*t2+0.000043506)*t2-0.000122226)*t2+
                                0.000434725)*t2-0.004394275)*t2+0.999999997;
                Q0 = t*(((((0.000008099*t2-0.000035614)*t2+0.000085844)*t2-
                                0.000218024)*t2+0.001144106)*t2-0.031249995);
                P1 = ((((0.000010632*t2-0.000050363)*t2+0.000145575)*t2-
                                0.000559487)*t2+0.007323931)*t2+1.000000004;
                Q1 = t*(((((-0.000009173*t2+0.000040658)*t2-0.000099941)*t2+
                                0.000266891)*t2-0.001601836)*t2+0.093749994);

                double TA0 = x - 0.25 * pi;
                double cosv = cos(TA0);
                double sinv = sin(TA0);

                BJ0 = a0*(P0*cosv-Q0*sinv);
                BY0 = a0*(P0*sinv+Q0*cosv);

                double TA1 = x - 0.75*pi;
                cosv = cos(TA1);
                sinv = sin(TA1);

                BJ1 = a0*(P1*cosv-Q1*sinv);
                BY1 = a0*(P1*sinv+Q1*cosv);
        }

        result[0] = BJ0 - I*BY0;
        result[1] = BJ1 - I*BY1;
}

void ZhangJinJY01Complex(dcomplex z, dcomplex *J, dcomplex *Y)
{
        dcomplex BJ0, BJ1, BY0, BY1;
        double norm = abs(z);
        double RP2 = 2.0 * oopi;
        dcomplex z1 = z;
        dcomplex ooz = 1./z;
        int k;

        if (norm < 12.0) { // for small arguments: use the series expansion

                dcomplex z2 = -0.25*z*z;
                double eps = 1e-10;
                double gamma = 0.5772156649015329;
                dcomplex logv = log(z1*0.5)+gamma;

                BJ0 = BJ1 = 1.0f;
                double W0 = 0;
                dcomplex CR1 = 1, CR0 = 1, CP1, CP2, CS1 = 1, CS2 = 0;
                double ook = 1.0, ookpe;

                for (k = 2; k < 41; k++) {
                        ookpe = 1.0/k;  // in fact k+1 -> incorporated in loop
                        dcomplex tmp = z2*ook;
                        CR0 *= tmp*ook;
                        CR1 *= tmp*ookpe;
                        BJ0 += CR0;
                        BJ1 += CR1;
                        W0 += ook;
                        CP1 = CR1*(2.*W0+ookpe);
                        CP2 = CR0*W0;
                        CS1 += CP1;
                        CS2 += CP2;
                        if ((real(CP1) > -eps) && (imag(CP1) > -eps))
                                if ((real(CP1) <  eps) && (imag(CP1) <  eps))
                                        break;
                        ook = ookpe;
                }
                BY0 = RP2*logv*BJ0-RP2*CS2;
                BJ1 *= 0.5*z1;
                BY1 = RP2*(logv*BJ1-ooz-0.25*z1*CS1);
        } else { // for larger arguments: use the asymptotic representation

                double a[12] = {-.703125e-01,.112152099609375e+00,
                        -.5725014209747314e+00,.6074042001273483e+01,
                        -.1100171402692467e+03,.3038090510922384e+04,
                        -.1188384262567832e+06,.6252951493434797e+07,
                        -.4259392165047669e+09,.3646840080706556e+11,
                        -.3833534661393944e+13,.4854014686852901e+15
                };
                double b[12] = {.732421875e-01,-.2271080017089844e+00,
                        .1727727502584457e+01,-.2438052969955606e+02,
                        .5513358961220206e+03,-.1825775547429318e+05,
                        .8328593040162893e+06,-.5006958953198893e+08,
                        .3836255180230433e+10,-.3649010818849833e+12,
                        .4218971570284096e+14,-.5827244631566907e+16
                };
                double c[12] = {.1171875e+00,-.144195556640625e+00,
                        .6765925884246826e+00,-.6883914268109947e+01,
                        .1215978918765359e+03,-.3302272294480852e+04,
                        .1276412726461746e+06,-.6656367718817688e+07,
                        .4502786003050393e+09,-.3833857520742790e+11,
                        .4011838599133198e+13,-.5060568503314727e+15
                };
                double d[12] = {-.1025390625e+00,.2775764465332031e+00,
                        -.1993531733751297e+01,.2724882731126854e+02,
                        -.6038440767050702e+03,.1971837591223663e+05,
                        -.8902978767070678e+06,.5310411010968522e+08,
                        -.4043620325107754e+10,.3827011346598605e+12,
                        -.4406481417852278e+14,.6065091351222699e+16
                };

                int k0 = 12;
                if (norm > 35.) k0 = 10;
                if (norm > 50.) k0 = 8;
                dcomplex CT1 = z1-0.25*pi;
                dcomplex CP0 = 1, CR = ooz;
                dcomplex CQ0 = -0.125*ooz;
                dcomplex CP1 = 1, CQ1 = 0.375*ooz;

                for (k = 0; k < k0; k++) {
                        CR *= ooz;
                        CP0 += a[k]*CR;
                        CP1 += c[k]*CR;
                        CR *= ooz;
                        CQ0 += b[k]*CR;
                        CQ1 += d[k]*CR;
                }

                dcomplex CU = sqrt(RP2*ooz);
                dcomplex CUcos = CU*cos(CT1);
                dcomplex CUsin = CU*sin(CT1);

                BJ0 =  CP0*CUcos-CQ0*CUsin;
                BY0 =  CP0*CUsin+CQ0*CUcos;
                BJ1 =  CP1*CUsin+CQ1*CUcos;
                BY1 = -CP1*CUcos+CQ1*CUsin;
        }

        J[0] = BJ0;
        J[1] = BJ1;
        Y[0] = BY0;
        Y[1] = BY1;
}

// ========================================================================
// AMOS BESSEL AND HANKEL RANGE FUNCTIONS
// ========================================================================

void amosBessJrange(int fromOrder, int toOrder, dcomplex argument,
                    dcomplex *result)
{
        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = fromOrder;
        int kode = 1;           // no exponential scaling
        int NN = toOrder-fromOrder+1;  // calculate a range of besselJ functions
        double *cyr = new double[NN];
        double *cyi = new double[NN];

        zbesj_f77(&zr, &zi, &fnu, &kode, &NN, cyr, cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr))
                cerr << "ERROR while calculating bessJ range (code: "
                     << ierr << ")" << endl;

        for(int m = 0; m < toOrder-fromOrder+1; m++)
                result[m] = cyr[m] + I*cyi[m];

        delete [] cyr;
        delete [] cyi;
}

void amosBessJrangeNormalized(int fromOrder, int toOrder, dcomplex argument,
                              dcomplex *result)
{
        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = fromOrder;
        int kode = 2;           // no exponential scaling
        int NN = toOrder-fromOrder+1;  // calculate a range of besselJ functions
        double *cyr = new double[NN];
        double *cyi = new double[NN];

        zbesj_f77(&zr, &zi, &fnu, &kode, &NN, cyr, cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr))
                cerr << "ERROR while calculating bessJ range Normalized (code: "
                     << ierr << ")" << endl;

        for(int m = 0; m < toOrder-fromOrder+1; m++)
                result[m] = cyr[m] + I*cyi[m];

        delete [] cyr;
        delete [] cyi;
}

void amosBessYrange(int fromOrder, int toOrder, dcomplex argument,
                    dcomplex *result)
{
        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = fromOrder;
        int kode = 1;           // no exponential scaling
        int NN = toOrder-fromOrder+1;  // calculate a range of besselY functions

        // allocate memory for output values
        double *cyr = new double[NN];
        double *cyi = new double[NN];
        // allocate memory for work values
        double *work1 = new double[NN];
        double *work2 = new double[NN];

        zbesy_f77(&zr, &zi, &fnu, &kode, &NN, cyr,
                  cyi, &nz, work1, work2, &ierr);

        if ((ierr != 3) && (ierr))
                cerr << "ERROR while calculating bessY range (code: "
                     << ierr << ")" << endl;

        // convert output values to dcomplex
        for(int m = 0; m < toOrder-fromOrder+1; m++)
                result[m] = cyr[m] + I*cyi[m];

        // free memory
        delete [] cyr;
        delete [] cyi;

        delete [] work1;
        delete [] work2;
}

void amosHank2range(int fromOrder, int toOrder, dcomplex argument,
                    dcomplex *result)
{
        int NN = toOrder-fromOrder+1; // calculate a range of HankelH2 functions
        int m = 2;

        // see note at hank2 function
        if (abs(argument) < 1e-2) {
                dcomplex *temp = new dcomplex[NN];

                amosBessJrange(fromOrder, toOrder, argument, result);
                amosBessYrange(fromOrder, toOrder, argument, temp);

                for(m = 0; m < NN; m++)
                        result[m] -= I*temp[m];

                delete [] temp;
                return;
        }

        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = fromOrder;
        int kode = 1;           // no exponential scaling

        double *cyr = new double[NN];
        double *cyi = new double[NN];

        zbesh_f77(&zr, &zi, &fnu, &kode, &m, &NN, cyr, cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr)) {
                cerr << "ERROR while calculating bessH range"
                        " (code: " << ierr << ")" << endl;
                }

        for(m = 0; m < toOrder-fromOrder+1; m++)
                result[m] = cyr[m] + I*cyi[m];

        delete [] cyr;
        delete [] cyi;
}

void amosHank2rangeNormalized(int fromOrder, int toOrder, dcomplex argument,
                              dcomplex *result)
{
        int NN = toOrder-fromOrder+1; // calculate a range of HankelH2 functions
        int m = 2;

        // see note at hank2 function
        if (abs(argument) < 1e-2) {
                dcomplex *temp = new dcomplex[NN];

                amosBessJrange(fromOrder, toOrder, argument, result);
                amosBessYrange(fromOrder, toOrder, argument, temp);

                for(m = 0; m < NN; m++)
                        result[m] -= I*temp[m];

                delete [] temp;
                return;
        }

        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = fromOrder;
        int kode = 2;           // exponential scaling

        double *cyr = new double[NN];
        double *cyi = new double[NN];

        zbesh_f77(&zr, &zi, &fnu, &kode, &m, &NN, cyr, cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr)) {
                cerr << "ERROR while calculating bessH range Normalized"
                        " (code: " << ierr << ")" << endl;
                }

        for(m = 0; m < toOrder-fromOrder+1; m++)
                result[m] = cyr[m] + I*cyi[m];

        delete [] cyr;
        delete [] cyi;
}

void fastHankelSymm(int Q1, int Q2, dcomplex argument, dcomplex *result)
{
        int max = (Q1 > Q2) ? Q1 : Q2;
        int NN = max+1;    // calculate a range of HankelH2 functions
        int m = 2;

        // see note at hank2 function
        if (abs(argument) < 1e-2) {
                dcomplex *tempJ = new dcomplex[NN];
                dcomplex *tempY = new dcomplex[NN];

                amosBessJrange(0, max, argument, tempJ);
                amosBessYrange(0, max, argument, tempY);

                for(m = 0; m <= Q2; m++)
                        result[m+Q1] = tempJ[m] - I*tempY[m];
                for(m = 0; m < Q1; m++)
                        result[m] = exp((m-Q1)*pi*I)*
                                        (tempJ[Q1-m]-I*tempY[Q1-m]);

                delete [] tempJ;
                delete [] tempY;
                return;
        }

        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = 0;
        int kode = 1;           // no exponential scaling

        double *cyr = new double[NN];
        double *cyi = new double[NN];

        zbesh_f77(&zr, &zi, &fnu, &kode, &m, &NN, cyr, cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr))
                cerr << "ERROR while calculating bessH range"
                        " (code: " << ierr << ")" << endl;

        for(m = 0; m <= Q2; m++)
                result[m+Q1] = cyr[m]+I*cyi[m];
        for(m = 0; m < Q1; m++)
                result[m] = exp(-(Q1-m)*pi*I)*(cyr[Q1-m]+I*cyi[Q1-m]);

        delete [] cyr;
        delete [] cyi;
}

dcomplex HankelScaled(int order, dcomplex argument)
{
        int NN = 1;    // calculate a range of HankelH2 functions
        int m = 2;

        int nz, ierr;           // output error constants
        double zr = real(argument);
        double zi = imag(argument);
        double fnu = order;
        int kode = 2;           // exponential scaling!

        double cyr, cyi;
        zbesh_f77(&zr, &zi, &fnu, &kode, &m, &NN, &cyr, &cyi, &nz, &ierr);

        if ((ierr != 3) && (ierr))
                cerr << "ERROR while calculating bessJ range"
                        " (code: " << ierr << ")" << endl;

        return dcomplex(cyr, cyi);
}

// ========================================================================
// INVERSE ERROR FUNCTION
// ========================================================================

// Coefficients in rational approximations
const double a[] = {
        -3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02,
         1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00 };
const double b[] = {
        -5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02,
         6.680131188771972e+01, -1.328068155288572e+01 };
const double c1[] = {
        -7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00,
        -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00 };
const double d[] = {
        7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00,
        3.754408661907416e+00 };

double erfinv(double p)
{
        double q, r, res;
        p = 0.5*(p+1.0);

        if (p < 0.02425) {
                // Rational approximation for lower region
                q = sqrt(-2*log(p));
                res = (((((c1[0]*q+c1[1])*q+c1[2])*q+c1[3])*q+c1[4])*q+c1[5]) /
                        ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        } else if (p > 0.97575) {
                // Rational approximation for upper region
                q  = sqrt(-2*log(1-p));
                res = -(((((c1[0]*q+c1[1])*q+c1[2])*q+c1[3])*q+c1[4])*q+c1[5]) /
                        ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        } else {
                // Rational approximation for central region
                q = p - 0.5;
                r = q*q;
                res = (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q /
                        (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
        }
        return res/sqrt(2.0);
}
